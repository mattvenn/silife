# SPDX-FileCopyrightText: © 2021 Uri Shaked <uri@wokwi.com>
# SPDX-License-Identifier: MIT

from math import log2, ceil
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("--sub_size", default=8, type=int)
args = parser.parse_args()

width = 2
height = 2
sub_size = args.sub_size

template = """
// SPDX-FileCopyrightText: © 2021 Uri Shaked <uri@wokwi.com>
// SPDX-License-Identifier: MIT

/* DO NOT EDIT - this is an auto-generated file. */
/* generated by gen_highorder_grid.py */

module silife_grid_{width}x{height} (
    input wire reset,
    input wire clk,
    input wire enable,

    /* grid interconnect */
    input wire [{width_minus1}:0] i_n,
    input wire [{height_minus1}:0] i_e,
    input wire [{width_minus1}:0] i_s,
    input wire [{height_minus1}:0] i_w,
    input wire i_ne,
    input wire i_se,
    input wire i_sw,
    input wire i_nw,
    output wire [{width_minus1}:0] o_n,
    output wire [{height_minus1}:0] o_w,
    output wire [{width_minus1}:0] o_s,
    output wire [{height_minus1}:0] o_e,

    /* First port: read/write */
    input  wire [{row_select_bits}:0] row_select,
    input  wire [{width_minus1}:0] clear_cells,
    input  wire [{width_minus1}:0] set_cells,
    output wire [{width_minus1}:0] cells,

    /* Second port: read only */
    input  wire [{row_select_bits}:0] row_select2,
    output wire [{width_minus1}:0] cells2
);

  wire selected_y = row_select[{row_select_bits}];
  assign cells = selected_y ? {{cells_1_1, cells_1_0}} : {{cells_0_1, cells_0_0}};
  assign cells2 = row_select2[{row_select_bits}] ? {{cells2_1_1, cells2_1_0}} : {{cells2_0_1, cells2_0_0}};

  assign o_n = {{{o_n}}};
  assign o_e = {{{o_e}}};
  assign o_s = {{{o_s}}};
  assign o_w = {{{o_w}}};

  wire [{cell_values_bits}:0] cell_values = {{
    {cell_values}
  }};

  {cells}
endmodule
"""

cell_template = """
  wire [{sub_size_minus1}:0] n_{y}_{x};
  wire [{sub_size_minus1}:0] e_{y}_{x};
  wire [{sub_size_minus1}:0] s_{y}_{x};
  wire [{sub_size_minus1}:0] w_{y}_{x};
  wire [{sub_size_minus1}:0] cells_{y}_{x};
  wire [{sub_size_minus1}:0] cells2_{y}_{x};

  silife_grid_{sub_size}x{sub_size} subgrid_{y}_{x} (
      .reset (reset),
      .clk   (clk),
      .enable(enable),

      .i_nw({nw}),
      .i_n ({n}),
      .i_ne({ne}),
      .i_e ({e}),
      .i_se({se}),
      .i_s ({s}),
      .i_sw({sw}),
      .i_w ({w}),

      .o_n(n_{y}_{x}),
      .o_e(e_{y}_{x}),
      .o_s(s_{y}_{x}),
      .o_w(w_{y}_{x}),

      .row_select(row_select[{row_select_slice}]),
      .clear_cells(selected_y == 1'b{y} ? clear_cells[{slice}] : {sub_size}'b0),
      .set_cells(selected_y == 1'b{y} ? set_cells[{slice}] : {sub_size}'b0),
      .cells(cells_{y}_{x}),

      .row_select2(row_select2[{row_select_slice}]),
      .cells2(cells2_{y}_{x})
  );"""


def wireslice(offset):
    return "{}:{}".format((offset + 1) * sub_size - 1, offset * sub_size)


def cell(y, x, dy, dx):
    max_x = width - 1
    max_y = height - 1
    corner_x = x * sub_size - 1 if dx < 0 else (x + 1) * sub_size
    corner_y = y * sub_size - 1 if dy < 0 else (y + 1) * sub_size
    if y == 0 and dy < 0:
        if x == 0 and dx < 0:
            return "i_nw"
        if x == max_x and dx > 0:
            return "i_ne"
        return "i_n[{}]".format(corner_x)
    if y == max_y and dy > 0:
        if x == 0 and dx < 0:
            return "i_sw"
        if x == max_x and dx > 0:
            return "i_se"
        return "i_s[{}]".format(corner_x)
    if x == 0 and dx < 0:
        return "i_w[{}]".format(corner_y)
    if x == max_x and dx > 0:
        return "i_e[{}]".format(corner_y)
    if dy < 0:
        return "s_{}_{}[{}]".format(y + dy, x + dx, sub_size - 1 if dx < 0 else 0)
    return "n_{}_{}[{}]".format(y + dy, x + dx, sub_size - 1 if dx < 0 else 0)


def row(y, x, direction):
    if direction == "n":
        if y < 1:
            return "i_n[{}]".format(wireslice(x))
        else:
            return "s_{}_{}".format(y - 1, x)
    if direction == "e":
        if x + 1 >= width:
            return "i_e[{}]".format(wireslice(y))
        else:
            return "w_{}_{}".format(y, x + 1)
    if direction == "s":
        if y + 1 >= width:
            return "i_s[{}]".format(wireslice(x))
        else:
            return "n_{}_{}".format(y + 1, x)
    if direction == "w":
        if x < 1:
            return "i_w[{}]".format(wireslice(y))
        else:
            return "e_{}_{}".format(y, x - 1)


cell_values = []
for y in range(height, 0, -1):
    for line in range(sub_size, 0, -1):
        lo = (line - 1) * sub_size
        hi = line * sub_size - 1
        for x in range(width, 0, -1):
            cell_values.append(
                "subgrid_{y}_{x}.cell_values[{hi}:{lo}]".format(
                    y=y - 1, x=x - 1, hi=hi, lo=lo
                )
            )

cells = ""
for y in range(height):
    for x in range(width):
        cell_y_up = y * sub_size - 1
        cell_y_down = (y + 1) * sub_size
        cell_x_left = x * sub_size - 1
        cell_x_right = (x + 1) * sub_size
        params = {
            "sub_size": sub_size,
            "sub_size_minus1": sub_size - 1,
            "x": x,
            "y": y,
            "nw": cell(y, x, -1, -1),
            "n": row(y, x, "n"),
            "ne": cell(y, x, -1, 1),
            "e": row(y, x, "e"),
            "se": cell(y, x, 1, 1),
            "s": row(y, x, "s"),
            "sw": cell(y, x, 1, -1),
            "w": row(y, x, "w"),
            "slice": wireslice(x),
            "row_select_slice": "{}:0".format(ceil(log2(sub_size)) - 1),
        }
        cells += "  " + cell_template.format(**params).strip() + "\n\n\n"

width_bits = ceil(log2(width * sub_size))
height_bits = ceil(log2(height * sub_size))

print(
    template.format(
        o_n=", ".join(["n_0_{}".format(i) for i in reversed(range(width))]),
        o_e=", ".join(["e_{}_1".format(i) for i in reversed(range(width))]),
        o_s=", ".join(["s_1_{}".format(i) for i in reversed(range(width))]),
        o_w=", ".join(["w_{}_0".format(i) for i in reversed(range(width))]),
        cells=cells[2:],
        cell_values_bits=(width * sub_size * height * sub_size) - 1,
        cell_values=",\n    ".join(cell_values),
        width=width * sub_size,
        width_minus1=(width * sub_size) - 1,
        height=height * sub_size,
        height_minus1=(height * sub_size) - 1,
        offset_bits=width_bits + height_bits - 1,
        row_select_bits=height_bits - 1,
    ).strip()
)
